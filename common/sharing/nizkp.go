package sharing

import (
	"crypto/rand"
	"crypto/sha256"
	"errors"

	"github.com/coinbase/kryptology/pkg/core/curves"
)

// This file includes the NIZK Proof and verifcation generation for IMPLICATE

// Proves: NIZK{SK_i: g^(SK_i) = PK_i && PK_d^(SK_i)= K_i_d}
func GenerateNIZKProof(
	curve *curves.Curve,
	SK_i curves.Scalar, // Secret key of the node i
	PK_i curves.Point, // Public key of the node i
	PK_d curves.Point, // Public key of the dealer
	K_i_d curves.Point, // symmetric shared key of node i and dealer d
	g curves.Point, // generator of the group
) []byte {

	//random binding scalar
	r := curve.NewScalar().Random(rand.Reader)

	//commitment for the binding scalar
	R := g.Mul(r)
	S := PK_d.Mul(r)

	// check that r, R, S are all non-zero
	// repeat untill all are non-zero
	for {
		if !r.IsZero() && !R.IsIdentity() && !S.IsIdentity() {
			break
		} else {
			r = curve.NewScalar().Random(rand.Reader)
			R = g.Mul(r)
			S = PK_d.Mul(r)
		}
	}

	//random challenge e generated by Fiat-Shamir (for non-interactive)
	// e = hash(all the public papameters and the commitment values)
	e := Hash(g, PK_i, PK_d, K_i_d, R, S, curve)

	//SK_i * e + r
	d := SK_i.MulAdd(e, r)

	//proof = {d,R,S}
	proof := make([]byte, 0)
	proof = append(proof, d.Bytes()...)              // d is 32 bytes
	proof = append(proof, R.ToAffineCompressed()...) // 32 bytes for ed25519
	proof = append(proof, S.ToAffineCompressed()...) // 32 bytes for ed25519

	return proof
}

func Verify(u *Proof, g, PK_i, PK_d, K_i_d curves.Point, curve *curves.Curve) bool {

	//check that the proof values are not zero
	if u.d.IsZero() || u.R.IsIdentity() || u.S.IsIdentity() {
		return false
	}

	// re-construct the random challenge by hashing all the public parameters and the commitment values provided in the proof
	e := Hash(g, PK_i, PK_d, K_i_d, u.R, u.S, curve)

	// Verification check: (e * PK_i + R == d * g) && (e * K_i_d + S == d * PK_d)
	alpha := (PK_i.Mul(e)).Add(u.R)
	alphaDash := g.Mul(u.d)

	beta := (K_i_d.Mul(e)).Add(u.S)
	betaDash := PK_d.Mul(u.d)

	if alpha.Equal(alphaDash) && beta.Equal(betaDash) {
		return true
	}

	return false
}

type Proof struct {
	d curves.Scalar
	R curves.Point
	S curves.Point
}

// unpacks proofs from bytes
func UnpackProof(curve *curves.Curve, proofBytes []byte) (*Proof, error) {
	proof := Proof{}

	byteLen := 33 //k256

	if curve.Name == "ed25519" {
		byteLen = 32
	}

	if len(proofBytes) != 32+2*byteLen {
		return nil, errors.New("doesn't have expected length")
	}

	d, err := curve.Scalar.SetBytes(proofBytes[:32])
	if err != nil {
		return nil, err
	}
	proof.d = d

	R, err := curve.Point.FromAffineCompressed(proofBytes[32:(32 + byteLen)])
	if err != nil {
		return nil, err
	}
	proof.R = R

	S, err := curve.Point.FromAffineCompressed(proofBytes[(32 + byteLen):(32 + 2*byteLen)])
	if err != nil {
		return nil, err
	}
	proof.S = S

	return &proof, nil
}

// for generating random challenge using fiat-shamir
func Hash(g, PK_i, PK_d, K_i_d, R, S curves.Point, curve *curves.Curve) curves.Scalar {
	plaintext := make([]byte, 0)
	plaintext = append(plaintext, g.ToAffineCompressed()...)
	plaintext = append(plaintext, PK_i.ToAffineCompressed()...)
	plaintext = append(plaintext, PK_d.ToAffineCompressed()...)
	plaintext = append(plaintext, K_i_d.ToAffineCompressed()...)
	plaintext = append(plaintext, R.ToAffineCompressed()...)
	plaintext = append(plaintext, S.ToAffineCompressed()...)

	sum := sha256.Sum256(plaintext)
	c := curve.Scalar.Hash(sum[:])

	return c
}
